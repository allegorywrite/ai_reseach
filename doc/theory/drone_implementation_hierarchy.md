# ドローンを対象としたCBF/MPCの実機実装に関する階層的アプローチ

本ドキュメントでは、ドローンを対象としたControl Barrier Function (CBF)およびModel Predictive Control (MPC)の実機実装に関する階層的アプローチについて詳細に説明します。特に、理論研究で設計した制御入力（推力とモーメント）を実機に適用する際の変換方法や、実際の実験プラットフォームで利用可能な制御入力の種類と制約について焦点を当てます。

## 1. ドローン制御の階層的アーキテクチャ

### 1.1 階層的制御の必要性

ドローンの制御系設計では、高度な制御アルゴリズム（MPCやCBF）を直接全ての軸に適用するのではなく、複数の階層に分けた制御アーキテクチャを採用することが一般的です。この階層的アプローチが必要な理由は以下の通りです：

1. **計算負荷の分散**: 高レベル制御（MPC、CBFなど）は計算負荷が高く、低レベル制御（姿勢安定化など）は高速応答が必要であるため、機能を分離することで計算資源を効率的に利用できます。

2. **サンプリング周波数の違い**: 姿勢制御は高いサンプリング周波数（例：200-500Hz）が必要ですが、位置制御は比較的低い周波数（例：50-100Hz）でも十分であることが多いです。

3. **抽象化レベルの違い**: 高レベル制御は抽象的な目標（例：「この位置に移動せよ」）を扱い、低レベル制御は具体的な物理量（例：モーター出力）を制御します。

4. **実験プラットフォームの制約**: 多くの市販ドローンプラットフォーム（PX4、ArduPilot等）は、直接モーターコマンドではなく、姿勢や位置の参照値を受け付けるインターフェースを提供しています。

### 1.2 典型的な階層構造

ドローン制御の典型的な階層構造は以下の通りです：

1. **最高レベル（計画層）**: 経路計画、軌道生成
   - 入力: ミッション目標、環境地図
   - 出力: 時間パラメータ付き参照軌道（位置、速度、加速度など）
   - 周波数: 1-10Hz
   - アルゴリズム例: RRT*、A*、多項式軌道最適化

2. **高レベル（制御層）**: 位置・速度制御
   - 入力: 参照軌道、現在の状態推定
   - 出力: 目標姿勢（ロール、ピッチ、ヨー）と推力
   - 周波数: 50-100Hz
   - アルゴリズム例: MPC、CBF-QP、PID

3. **中間レベル（姿勢制御層）**: 姿勢制御
   - 入力: 目標姿勢と推力
   - 出力: 角速度指令と推力
   - 周波数: 200-400Hz
   - アルゴリズム例: 幾何学的制御、バックステッピング制御、PID

4. **低レベル（モーター制御層）**: モーター速度制御
   - 入力: 角速度指令と推力
   - 出力: モーターPWM信号
   - 周波数: 500-1000Hz
   - アルゴリズム例: PID、フィードフォワード制御

### 1.3 階層間のインターフェース

階層間のインターフェースは、上位層から下位層への指令の伝達方法を定義します。典型的なインターフェースは以下の通りです：

1. **計画層→制御層**: 参照軌道（位置、速度、加速度、ジャーク）
   - 形式: 多項式スプライン、離散的なウェイポイント列、時間パラメータ付き曲線

2. **制御層→姿勢制御層**: 目標姿勢と推力
   - 形式: ロール・ピッチ・ヨー角（またはクォータニオン）と正規化推力

3. **姿勢制御層→モーター制御層**: 角速度指令と推力
   - 形式: 3軸の角速度ベクトルと正規化推力

4. **モーター制御層→アクチュエータ**: モーターPWM信号
   - 形式: 各モーターへのPWM値（通常は1000-2000μsの範囲）

## 2. 理論研究と実機実装のギャップ

### 2.1 理論研究における制御入力

理論研究では、ドローンのダイナミクスを以下のように定式化することが一般的です：

$$\dot{R} = R \omega^\wedge$$
$$\dot{p} = v$$
$$m \dot{v} = m g e_3 + R f e_3$$
$$J \dot{\omega} = J \omega \times \omega + \tau$$

ここで、制御入力は以下のベクトルとして定義されます：

$$u = [f, \tau_x, \tau_y, \tau_z]^T$$

ここで：
- $f$ は合計推力（スラスト）
- $\tau = [\tau_x, \tau_y, \tau_z]^T$ は3軸のトルク入力

この制御入力は、理論的には完全なシステム制御を可能にしますが、実機への直接適用には以下の課題があります：

1. **不安定性**: 推力とモーメントを直接入力すると、積分誤差や外乱に対して不安定になりやすい
2. **プラットフォーム非互換性**: 多くの実験プラットフォームは推力とモーメントを直接受け付けない
3. **モデル誤差**: 実機のダイナミクスは理想的なモデルと異なり、推力とモーメントの直接制御では誤差が蓄積する

### 2.2 実機プラットフォームの制御インターフェース

実際のドローン実験プラットフォーム（PX4、ArduPilot等）は、以下のような制御インターフェースを提供しています：

1. **位置制御モード**:
   - 入力: 目標位置、速度、加速度（オプション）
   - 内部: プラットフォームが自動的に姿勢制御と推力制御を行う
   - 周波数: 通常50-100Hz

2. **姿勢制御モード**:
   - 入力: 目標姿勢（ロール、ピッチ、ヨー）と推力
   - 内部: プラットフォームが自動的に角速度制御とモーター制御を行う
   - 周波数: 通常100-200Hz

3. **レート制御モード**:
   - 入力: 目標角速度と推力
   - 内部: プラットフォームがモーター制御を行う
   - 周波数: 通常200-400Hz

4. **ダイレクトモーター制御モード**:
   - 入力: 各モーターへのPWM値
   - 内部: 最小限の処理のみ
   - 周波数: 通常500-1000Hz

研究用途では、通常は姿勢制御モードまたはレート制御モードを使用することが多いです。

## 3. 階層的CBF/MPC実装アプローチ

### 3.1 高レベル制御：CBF/MPC

高レベル制御層では、CBFやMPCを用いて安全性と最適性を確保します。この層の入出力は以下の通りです：

**入力**:
- 参照軌道（位置、速度、加速度）
- 現在の状態推定（位置、速度、姿勢）
- 環境情報（障害物位置など）

**出力**:
- 目標加速度ベクトル $a_{des} \in \mathbb{R}^3$
- 目標ヨー角 $\psi_{des}$

**アルゴリズム**:
1. CBF-QPを解いて安全な目標加速度を計算：
   $$\min_{a_{des}} \|a_{des} - a_{ref}\|^2$$
   $$\text{s.t.} \quad \mathcal{L}_f h(x) + \mathcal{L}_g h(x) a_{des} + \alpha(h(x)) \geq 0$$
   $$\|a_{des}\| \leq a_{max}$$

2. MPCを用いて最適な軌道を計算：
   $$\min_{a_{des}(0), \ldots, a_{des}(N-1)} \sum_{k=0}^{N-1} \|p(k) - p_{ref}(k)\|_Q^2 + \|v(k) - v_{ref}(k)\|_R^2 + \|a_{des}(k)\|_S^2$$
   $$\text{s.t.} \quad p(k+1) = p(k) + v(k) \Delta t + \frac{1}{2} a_{des}(k) \Delta t^2$$
   $$v(k+1) = v(k) + a_{des}(k) \Delta t$$
   $$h(p(k), v(k)) \geq 0 \quad \text{(CBF制約)}$$
   $$\|a_{des}(k)\| \leq a_{max}$$

### 3.2 中間層：加速度から姿勢への変換

目標加速度ベクトル $a_{des}$ から目標姿勢（ロール $\phi_{des}$、ピッチ $\theta_{des}$、ヨー $\psi_{des}$）と正規化推力 $T_{des}$ への変換は以下のように行います：

1. 目標推力ベクトルの計算：
   $$\vec{T}_{des} = m(a_{des} - \vec{g})$$

2. 推力の大きさの計算：
   $$T_{des} = \|\vec{T}_{des}\|$$

3. 目標姿勢の計算：
   - 目標$z$軸方向（推力方向）：$\vec{z}_{B,des} = \frac{\vec{T}_{des}}{\|\vec{T}_{des}\|}$
   - 目標$x$軸方向（前方方向）：
     $$\vec{x}_{C,des} = [\cos\psi_{des}, \sin\psi_{des}, 0]^T$$
     $$\vec{y}_{B,des} = \frac{\vec{z}_{B,des} \times \vec{x}_{C,des}}{\|\vec{z}_{B,des} \times \vec{x}_{C,des}\|}$$
     $$\vec{x}_{B,des} = \vec{y}_{B,des} \times \vec{z}_{B,des}$$
   
   - 目標回転行列：$R_{des} = [\vec{x}_{B,des}, \vec{y}_{B,des}, \vec{z}_{B,des}]$
   
   - オイラー角への変換：
     $$\phi_{des} = \text{atan2}(R_{des,32}, R_{des,33})$$
     $$\theta_{des} = \text{asin}(-R_{des,31})$$
     $$\psi_{des} = \text{atan2}(R_{des,21}, R_{des,11})$$

4. 正規化推力の計算：
   $$T_{norm} = \frac{T_{des}}{T_{max}}$$

この変換により、高レベル制御層の出力（目標加速度）を中間層の入力（目標姿勢と推力）に変換できます。

### 3.3 低レベル制御：姿勢制御

低レベル制御層では、目標姿勢と推力を実現するための姿勢制御を行います。この層は通常、ドローンのフライトコントローラ（PX4、ArduPilotなど）に実装されています。

**入力**:
- 目標姿勢（ロール $\phi_{des}$、ピッチ $\theta_{des}$、ヨー $\psi_{des}$）
- 正規化推力 $T_{norm}$
- 現在の姿勢推定

**出力**:
- モーターコマンド（PWM信号）

**アルゴリズム**:
1. 姿勢誤差の計算：
   $$e_R = \frac{1}{2}(R_{des}^T R - R^T R_{des})^\vee$$
   $$e_\omega = \omega - R^T R_{des} \omega_{des}$$

2. 目標トルクの計算：
   $$\tau_{des} = -K_R e_R - K_\omega e_\omega + \omega \times J \omega - J(\hat{\omega} R^T R_{des} \omega_{des} - R^T R_{des} \dot{\omega}_{des})$$

3. モーターコマンドへの変換：
   $$\begin{bmatrix} F_1 \\ F_2 \\ F_3 \\ F_4 \end{bmatrix} = \begin{bmatrix} 1 & 0 & -L & -c_\tau \\ 1 & L & 0 & c_\tau \\ 1 & 0 & L & -c_\tau \\ 1 & -L & 0 & c_\tau \end{bmatrix} \begin{bmatrix} T_{des} \\ \tau_{des,x} \\ \tau_{des,y} \\ \tau_{des,z} \end{bmatrix}$$

   ここで、$L$はアーム長、$c_\tau$は推力-トルク変換係数です。

4. PWM信号への変換：
   $$PWM_i = k_1 \sqrt{F_i} + k_0$$

   ここで、$k_0$と$k_1$はキャリブレーションパラメータです。

## 4. 多項式軌道表現とMPC/CBFの統合

### 4.1 多項式軌道表現

多項式軌道表現は、ドローンの軌道を滑らかな多項式関数として表現する方法です。一般的には、各軸（x, y, z）に対して独立した多項式を用います：

$$p_x(t) = \sum_{i=0}^n a_{x,i} t^i, \quad p_y(t) = \sum_{i=0}^n a_{y,i} t^i, \quad p_z(t) = \sum_{i=0}^n a_{z,i} t^i$$

ここで、$a_{x,i}$, $a_{y,i}$, $a_{z,i}$ は多項式係数、$n$は多項式の次数です。

多項式軌道の利点は以下の通りです：
- 滑らかさ：高次微分（速度、加速度、ジャーク等）が連続
- 解析的な微分：速度、加速度等を解析的に計算可能
- コンパクトな表現：少数のパラメータで複雑な軌道を表現可能
- 最適性：最小スナップ等の最適性基準を満たす軌道を生成可能

### 4.2 多項式軌道とMPCの統合

多項式軌道とMPCを統合する方法には、以下のアプローチがあります：

1. **参照軌道としての利用**:
   - 多項式軌道を生成し、それをMPCの参照軌道として使用
   - MPCは参照軌道からの偏差を最小化するように制御入力を計算

2. **MPC内での多項式パラメータ最適化**:
   - MPCの決定変数として多項式係数を直接最適化
   - 制約条件として多項式の連続性や境界条件を課す

3. **モデル予測輪郭制御（MPCC）**:
   - 空間的な参照曲線（多項式スプライン等）を定義
   - 時間パラメータをMPCの決定変数として最適化
   - 曲線に沿った進行と偏差の両方を考慮した目的関数を設計

### 4.3 多項式軌道とCBFの統合

多項式軌道とCBFを統合する方法には、以下のアプローチがあります：

1. **CBF安全フィルタの適用**:
   - 多項式軌道を生成
   - CBF-QPを用いて軌道を安全に修正
   - 修正された軌道を追従

2. **CBF制約付き軌道最適化**:
   - 軌道最適化問題にCBF制約を追加
   - 最適化問題を解いて安全な多項式軌道を生成

3. **オンライン軌道再計画**:
   - CBF違反が検出された場合に軌道を再計画
   - 新しい安全な多項式軌道を生成

### 4.4 実装例：最小スナップ軌道とCBF-MPC

以下に、最小スナップ軌道とCBF-MPCを統合した実装例を示します：

1. **オフライン軌道生成**:
   - ウェイポイント間の最小スナップ軌道を生成
   - 各区間を7次多項式で表現：$p(t) = \sum_{i=0}^7 a_i t^i$
   - 境界条件（位置、速度、加速度、ジャーク）を満たすように係数を最適化

2. **オンラインCBF-MPC**:
   - 状態：$x = [p^T, v^T]^T$
   - 制御入力：$u = a$（加速度）
   - 参照軌道：$p_{ref}(t)$, $v_{ref}(t)$, $a_{ref}(t)$（多項式軌道から計算）
   - CBF：$h(x) = \|p - p_{obs}\|^2 - r_{safe}^2$（障害物回避）
   - MPC問題：
     $$\min_{a(0), \ldots, a(N-1)} \sum_{k=0}^{N-1} \|p(k) - p_{ref}(t_k)\|_Q^2 + \|v(k) - v_{ref}(t_k)\|_R^2 + \|a(k) - a_{ref}(t_k)\|_S^2$$
     $$\text{s.t.} \quad p(k+1) = p(k) + v(k) \Delta t + \frac{1}{2} a(k) \Delta t^2$$
     $$v(k+1) = v(k) + a(k) \Delta t$$
     $$h(p(k), v(k)) + \alpha h(p(k), v(k)) + \mathcal{L}_f h(p(k), v(k)) + \mathcal{L}_g h(p(k), v(k)) a(k) \geq 0$$
     $$\|a(k)\| \leq a_{max}$$

3. **階層的制御実装**:
   - CBF-MPCの出力（目標加速度）を目標姿勢と推力に変換
   - 目標姿勢と推力をフライトコントローラに送信
   - フライトコントローラが姿勢制御とモーター制御を実行

## 5. 実機実装の実践的考慮事項

### 5.1 計算効率とリアルタイム実装

実機実装では、計算効率とリアルタイム性が重要です。以下の手法を用いて、計算効率を向上させることができます：

1. **Explicit MPC**:
   - オフラインで最適解を計算し、テーブル化
   - オンラインでは単純なテーブル参照のみ
   - 計算コストを大幅に削減可能

2. **線形化と簡略化**:
   - 非線形ダイナミクスを線形化
   - 高次の項を無視して簡略化
   - 計算コストを削減しつつ、十分な精度を維持

3. **並列計算**:
   - GPUやマルチコアCPUを活用
   - 独立した計算を並列化
   - 計算時間を短縮

4. **早期終了条件**:
   - 最適化アルゴリズムの反復回数に上限を設定
   - 収束条件を緩和
   - 厳密な最適解ではなく、実用的な近似解を採用

### 5.2 センサノイズと状態推定

実機実装では、センサノイズと状態推定の不確かさが問題となります。以下の手法を用いて、これらの問題に対処できます：

1. **ロバスト制御**:
   - ノイズや不確かさを明示的にモデル化
   - 最悪ケースでも安全性を保証するロバストCBF
   - 不確かさを考慮したロバストMPC

2. **状態推定の改善**:
   - 拡張カルマンフィルタ（EKF）や粒子フィルタを用いた状態推定
   - センサフュージョン（IMU、カメラ、GPS等）
   - 外乱オブザーバを用いた外乱推定

3. **適応制御**:
   - システムパラメータをオンラインで推定
   - 推定されたパラメータに基づいて制御則を適応的に調整
   - モデル誤差の影響を低減

### 5.3 フェイルセーフと安全対策

実機実験では、安全性が最も重要です。以下の安全対策を実装することをお勧めします：

1. **バックアップ制御器**:
   - 高度な制御器（MPC、CBF等）が失敗した場合のバックアップとしてシンプルなPID制御器を用意
   - 制御器の切り替え条件を明確に定義

2. **仮想安全壁**:
   - 実験領域の境界にCBFによる仮想安全壁を設定
   - 境界を超えようとすると自動的に阻止

3. **緊急停止機能**:
   - リモコンの緊急停止ボタン
   - 異常検出時の自動緊急着陸
   - 通信途絶時の自動帰還

4. **段階的テスト**:
   - シミュレーションでの十分な検証
   - 拘束条件下での初期テスト
   - 制限された空間での飛行テスト
   - 徐々に複雑な環境でのテスト

## 6. 結論

本ドキュメントでは、ドローンを対象としたCBF/MPCの実機実装に関する階層的アプローチについて詳細に説明しました。理論研究で設計した制御入力（推力とモーメント）を実機に適用する際の変換方法や、実際の実験プラットフォームで利用可能な制御入力の種類と制約について解説しました。

階層的制御アーキテクチャを採用することで、計算負荷の分散、サンプリング周波数の違いへの対応、抽象化レベルの違いの管理、実験プラットフォームの制約への適応が可能になります。高レベル制御層ではCBFやMPCを用いて安全性と最適性を確保し、中間層では目標加速度から目標姿勢と推力への変換を行い、低レベル制御層では姿勢制御とモーター制御を実行します。

多項式軌道表現とMPC/CBFの統合により、滑らかで安全な軌道の生成と追従が可能になります。実機実装では、計算効率とリアルタイム性、センサノイズと状態推定、フェイルセーフと安全対策に注意を払う必要があります。

これらの知見を活かすことで、理論研究の成果を実機実験に効果的に適用し、安全かつ高性能なドローン制御システムを実現することができます。
